# -*- coding: utf-8 -*-
"""Welcome to Colaboratory

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb
"""

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from bson import ObjectId
from motor.motor_asyncio import AsyncIOMotorClient
from datetime import datetime
from typing import List, Optional

app = FastAPI()

# MongoDB client setup
client = AsyncIOMotorClient("mongodb+srv://adityarai0132:aditya11@cluster0.6ir5k.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0")  # Update with your MongoDB connection string
db = client['fast_api']  # Replace with your database name
items_collection = db['items']  # Replace with your collection name

# Pydantic model for item
class Item(BaseModel):
    name: str
    email: str
    item_name: str
    quantity: int
    expiry_date: str  # Expecting 'YYYY-MM-DD'

class ItemInDB(Item):
    id: str
    insert_date: str

# Helper function to get current timestamp
def get_current_timestamp():
    return datetime.now().isoformat()

@app.post("/items", response_model=ItemInDB)
async def create_item(item: Item):
    insert_date = get_current_timestamp()
    new_item = {
        "name": item.name,
        "email": item.email,
        "item_name": item.item_name,
        "quantity": item.quantity,
        "expiry_date": item.expiry_date,
        "insert_date": insert_date
    }
    result = await items_collection.insert_one(new_item)
    return ItemInDB(**new_item, id=str(result.inserted_id), insert_date=insert_date)

@app.get("/items/{id}", response_model=ItemInDB)
async def get_item(id: str):
    item = await items_collection.find_one({"_id": ObjectId(id)})
    if item is None:
        raise HTTPException(status_code=404, detail="Item not found")
    return ItemInDB(**item, id=str(item["_id"]))

@app.get("/items/filter", response_model=List[ItemInDB])
async def filter_items(
    email: Optional[str] = None,
    expiry_date: Optional[str] = None,
    insert_date: Optional[str] = None,
    quantity: Optional[int] = None
):
    query = {}

    if email:
        query["email"] = email
    if expiry_date:
        query["expiry_date"] = {"$gt": expiry_date}  # Items expiring after the provided date
    if insert_date:
        query["insert_date"] = {"$gt": insert_date}  # Items inserted after the provided date
    if quantity is not None:
        query["quantity"] = {"$gte": quantity}  # Quantity greater than or equal to the provided number

    items = await items_collection.find(query).to_list(100)  # Limit to 100 for performance
    return [ItemInDB(**item, id=str(item["_id"])) for item in items]

@app.delete("/items/{id}")
async def delete_item(id: str):
    result = await items_collection.delete_one({"_id": ObjectId(id)})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Item not found")
    return {"detail": "Item deleted successfully"}

@app.put("/items/{id}", response_model=ItemInDB)
async def update_item(id: str, item: Item):
    existing_item = await items_collection.find_one({"_id": ObjectId(id)})
    if existing_item is None:
        raise HTTPException(status_code=404, detail="Item not found")

    updated_item = {
        "name": item.name,
        "email": item.email,
        "item_name": item.item_name,
        "quantity": item.quantity,
        "expiry_date": item.expiry_date
    }

    await items_collection.update_one({"_id": ObjectId(id)}, {"$set": updated_item})
    return ItemInDB(**{**existing_item, **updated_item}, id=id)

@app.get("/items/aggregate/email_count")
async def aggregate_email_count():
    pipeline = [
        {"$group": {"_id": "$email", "count": {"$sum": 1}}}
    ]
    result = await items_collection.aggregate(pipeline).to_list(100)
    return [{"email": item["_id"], "count": item["count"]} for item in result]

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, EmailStr
from motor.motor_asyncio import AsyncIOMotorClient
from bson import ObjectId
from datetime import datetime

app = FastAPI()

# MongoDB connection
client = AsyncIOMotorClient("mongodb+srv://adityarai0132:aditya11@cluster0.6ir5k.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0")
db = client.fast_api
clock_in_collection = db.user_clock_in_records

# Pydantic models
class ClockInEntry(BaseModel):
    email: EmailStr
    location: str

class ClockInRecord(BaseModel):
    id: str
    email: EmailStr
    location: str
    insert_datetime: datetime

# Helper function to convert MongoDB ObjectId to string
def item_helper(item) -> dict:
    return {
        "id": str(item["_id"]),
        "email": item["email"],
        "location": item["location"],
        "insert_datetime": item["insert_datetime"]
    }

# POST /clock-in: Create a new clock-in entry
@app.post("/clock-in", response_model=ClockInRecord)
async def create_clock_in(clock_in: ClockInEntry):
    clock_in_data = clock_in.dict()
    clock_in_data["insert_datetime"] = datetime.utcnow()  # Automatically insert current datetime
    new_clock_in = await clock_in_collection.insert_one(clock_in_data)
    created_clock_in = await clock_in_collection.find_one({"_id": new_clock_in.inserted_id})
    return item_helper(created_clock_in)

# GET /clock-in/{id}: Retrieve a clock-in record by ID
@app.get("/clock-in/{id}", response_model=ClockInRecord)
async def get_clock_in_by_id(id: str):
    clock_in = await clock_in_collection.find_one({"_id": ObjectId(id)})
    if clock_in:
        return item_helper(clock_in)
    raise HTTPException(status_code=404, detail="Clock-in record not found")

# GET /clock-in/filter: Filter clock-in records by Email, Location, or Insert DateTime
@app.get("/clock-in/filter")
async def filter_clock_ins(email: str = None, location: str = None, after_date: str = None):
    query = {}
    if email:
        query["email"] = email
    if location:
        query["location"] = location
    if after_date:
        after_datetime = datetime.strptime(after_date, "%Y-%m-%dT%H:%M:%S")
        query["insert_datetime"] = {"$gt": after_datetime}

    filtered_clock_ins = await clock_in_collection.find(query).to_list(100)
    return [item_helper(clock_in) for clock_in in filtered_clock_ins]

# DELETE /clock-in/{id}: Delete a clock-in record by ID
@app.delete("/clock-in/{id}")
async def delete_clock_in(id: str):
    delete_result = await clock_in_collection.delete_one({"_id": ObjectId(id)})
    if delete_result.deleted_count == 1:
        return {"message": "Clock-in record deleted successfully"}
    raise HTTPException(status_code=404, detail="Clock-in record not found")

# PUT /clock-in/{id}: Update a clock-in record by ID (excluding Insert DateTime)
@app.put("/clock-in/{id}")
async def update_clock_in(id: str, clock_in: ClockInEntry):
    update_data = clock_in.dict(exclude_unset=True)
    updated_clock_in = await clock_in_collection.update_one(
        {"_id": ObjectId(id)},
        {"$set": update_data}
    )
    if updated_clock_in.modified_count == 1:
        updated_record = await clock_in_collection.find_one({"_id": ObjectId(id)})
        return item_helper(updated_record)
    raise HTTPException(status_code=404, detail="Clock-in record not found")

